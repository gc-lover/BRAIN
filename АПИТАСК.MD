# АПИТАСК - Инструкция для API Task Creator Agent

**Статус:** approved  
**Версия:** 1.0.0  
**Дата создания:** 2025-11-07  
**Последнее обновление:** 2025-11-08 12:25  
**api-readiness:** not-applicable  
**api-readiness-check-date:** 2025-11-08 12:25
**api-readiness-notes:** Служебная инструкция для API Task Creator Agent; обновлена под 100% микросервисный backend и новый Production URL

---

## Роль и ограничения

- **Роль:** API Task Creator (ДУАПИТАСК). Создаёт детальные задания для API Executor на основе документов `.BRAIN`.
- **Не выполняет:** не пишет OpenAPI спецификации (за это отвечает `АПИТАСК`), не реализует backend (`БЭКТАСК`), не создаёт фронтенд (`ФРОНТТАСК`), не утверждает содержимое `.BRAIN` (это зона `МЕНЕДЖЕР`/Brain Readiness Checker).
- **Передача дальше:** каждое созданное задание обязателен к исполнению агент `АПИТАСК`.

---

## Краткий обзор

API Task Creator Agent - это AI помощник для создания задач API из документов .BRAIN. Преобразует концепции и механики в задачи для АПИТАСК агента в API-SWAGGER с учетом микросервисной архитектуры.

**Цель:** Создавать качественные задачи для API спецификаций с указанием целевого микросервиса.

**Минимальный вход для работы:**
- ПРАВИЛО: `.cursor/rules/api-task-creator-rules.mdc`
- ИНСТРУКЦИЯ: Этот файл (АПИТАСК.MD из .BRAIN)
- ДОКУМЕНТ: Готовый документ из .BRAIN с api-readiness: ready

---

## Микросервисная архитектура (ОБЯЗАТЕЛЬНО!)

- Backend полностью микросервисный. Все задачи должны ссылаться исключительно на сервисы из таблицы ниже — монолитные сценарии больше не поддерживаются.
- Все вызовы проходят через единый gateway `https://api.necp.game/v1`, который маршрутизирует их к необходимому микросервису.
- Интеграции между сервисами оформляй явными контрактами (REST, Kafka, gRPC) без обходных вызовов.
- В OpenAPI спецификациях обязательно добавляй `info.x-microservice` с именем, портом, доменом и базовым путем сервиса. Исключение — общие библиотеки компонентов в `api/v1/shared/`, они подключаются только через `$ref`.
- Каждой спецификации соответствует каталог `api/v1/<microservice>/<domain>/`; поддерживай эту структуру, не превышай лимит 400 строк на файл и выноси избыточный контент в дополнительные части с суффиксами `_0001`, `_0002`.

## ⚠️ ВАЖНО: Стандартные URL для API (ОБЯЗАТЕЛЬНО!)

**Правильные URL для OpenAPI спецификаций:**

### Production API:
- **HTTP:** `https://api.necp.game/v1`
- **WebSocket:** `wss://api.necp.game/v1`
- **Описание:** Production API Gateway

### Локальная разработка:
- **API Gateway:** `http://localhost:8080/api/v1`
- **Прямой доступ к микросервисам:** `http://localhost:{port}/api/v1`

**⚠️ КРИТИЧНО:** Все OpenAPI файлы ДОЛЖНЫ использовать ОДИНАКОВЫЙ домен!
- ✅ Правильно: `https://api.necp.game/v1`
- ❌ Неправильно: `https://api.necpgame.com/v1` (устаревший)
- ❌ Неправильно: `https://necpgame.com/api/v1` (неправильный формат)

---

## Полезные команды

- Не забывай проверять валидность своих OpenAPI файлов: `npx swagger-cli validate`

При создании API задачи ВСЕГДА указывать целевой микросервис:

### Распределение доменов

| Микросервис | Порт | Домен | API маршруты | Каталог (пример) |
|-------------|------|-------|--------------|------------------|
| **auth-service** | 8081 | Аутентификация | `/api/v1/auth/*` | `api/v1/auth/sessions/` |
| **character-service** | 8082 | Персонажи | `/api/v1/characters/*`, `/api/v1/players/*` | `api/v1/characters/profiles/` |
| **gameplay-service** | 8083 | Геймплей | `/api/v1/gameplay/*` | `api/v1/gameplay/combat/` |
| **social-service** | 8084 | Социальное | `/api/v1/social/*` | `api/v1/social/resonance/` |
| **economy-service** | 8085 | Экономика | `/api/v1/economy/*` | `api/v1/economy/market/` |
| **world-service** | 8086 | Мир | `/api/v1/world/*` | `api/v1/world/anomalies/` |

---

## Правила создания задач

### 1. Определение микросервиса

**Перед созданием задачи:**
1. Прочитать документ из .BRAIN
2. Определить к какому домену относится механика
3. Указать целевой микросервис в задаче
4. Зафиксировать целевой каталог `api/v1/<microservice>/<domain>/`

**Примеры:**

**Документ:** `authentication-authorization-system.md`
- Домен: Аутентификация
- Микросервис: **auth-service (8081)**
- API путь: `/api/v1/auth/*`
- Каталог: `api/v1/auth/sessions/`

**Документ:** `guild-system-backend.md`
- Домен: Социальные механики
- Микросервис: **social-service (8084)**
- API путь: `/api/v1/social/guilds/*`
- Каталог: `api/v1/social/guilds/`

**Документ:** `combat-session-backend.md`
- Домен: Боевая система
- Микросервис: **gameplay-service (8083)**
- API путь: `/api/v1/gameplay/combat/*`
- Каталог: `api/v1/gameplay/combat/`

**Документ:** `inventory-system.md`
- Домен: Экономика
- Микросервис: **economy-service (8085)**
- API путь: `/api/v1/economy/inventory/*`
- Каталог: `api/v1/economy/inventory/`

---

### 2. Формат задачи

При создании задачи в API-SWAGGER обязательно указывать:

```markdown
## Микросервис

**Target Microservice:** [service-name]  
**Port:** [port]  
**API Path:** /api/v1/[domain]/*

**API Gateway Route:**
```yaml
- id: [service-name]
  uri: lb://[SERVICE-NAME]
  predicates:
    - Path=/api/v1/[domain]/**
```

## Endpoints

### GET/POST/PUT/DELETE /api/v1/[domain]/[resource]

...
```

### 2.1 Метаданные OpenAPI (обязательные)

Каждая боевая OpenAPI спецификация должна содержать секцию `info.x-microservice`:

```yaml
info:
  title: Feature API
  version: 1.0.0
  description: API описание
  x-microservice:
    name: gameplay-service        # Имя микросервиса
    port: 8083                    # Порт микросервиса
    domain: gameplay              # Домен API
    base-path: /api/v1/gameplay   # Базовый путь
    directory: api/v1/gameplay/combat  # Каталог OpenAPI
    package: com.necpgame.gameplayservice  # Java пакет
```

⚠️ Без этой секции скрипт генерации кода остановит работу. Используйте таблицу в начале документа для выбора корректных значений.

---

### 3. Межсервисное взаимодействие

Если API нуждается в данных из других микросервисов, указать:

```markdown
## Service Communication

**Calls (Feign Client):**
- auth-service: validateToken()
- character-service: getCharacter()

**Events (Event Bus):**
- Publishes: [event-name]
- Subscribes: [event-name]
```

**Пример:**

**Задача:** Create Character API (character-service)

```markdown
## Service Communication

**Calls:**
- auth-service: validateToken(token) - проверка прав доступа

**Events:**
- Publishes: `character:created`
- Subscribes: `account:created` - создать character slots
```

---

### 4. Event-driven механики

Для асинхронных операций указывать Event Bus события:

**Пример: Loot System**

```markdown
## Event Bus Integration

**Subscribes to:**
- `combat:enemy-killed` → generate loot
- `raid:boss-defeated` → generate boss loot

**Publishes:**
- `loot:generated` → notify players
- `legendary:dropped` → global announcement
```

---

### 5. Управление сводными файлами

- При обновлении общих сводных файлов (`API-SWAGGER/tasks/config/brain-mapping.yaml`, readiness трекеров, очередей заданий и т.д.) соблюдай ограничение в 400 строк
- Если файл достигает лимита, создавай новую версию с суффиксом `_0001`, `_0002`, переносом актуальных данных и ссылкой на предыдущую часть
- Суффикс увеличивай на единицу с ведущими нулями, чтобы сохранять корректную сортировку и навигацию

### 6. Implementation-tracker

- После merge спецификации обязательно добавь/обнови запись в `implementation-tracker.yaml`, используя тот же `api_path`, что и Target Directory в задании (`api/v1/<microservice>/<domain>/...`).
- Проверяй, что поля `backend` и `frontend` ссылаются на правильные каталоги; при превышении лимита 400 строк создавай новую версию файла с суффиксом `_0001`, `_0002`.
- Если спецификация перемещена в новый каталог, синхронно обнови `brain-mapping.yaml`, `implementation-tracker.yaml` и документы `.BRAIN`, чтобы избежать рассинхронизации.

---

## Шаблон API задачи

```markdown
# API Task: [Название системы]

**Target Microservice:** [service-name]  
**Port:** [port]  
**Domain:** [domain]  
**Target Directory:** api/v1/[microservice]/[domain]/  
**Priority:** high/medium/low  
**Status:** draft

---

## Source Document

**Path:** `.BRAIN/[path-to-doc]`  
**Version:** [version]  
**API Readiness:** ready

---

## Микросервис

**Service:** [service-name] ([port])  
**API Path:** /api/v1/[domain]/*  
**Directory:** api/v1/[microservice]/[domain]/  
**API Gateway:** http://localhost:8080/api/v1/[domain]/*

---

## API Endpoints

### POST /api/v1/[domain]/[resource]

**Description:** [описание]

**Request:**
```json
{
  "field": "value"
}
```

**Response 200:**
```json
{
  "id": "uuid",
  "result": "success"
}
```

### GET /api/v1/[domain]/[resource]/{id}

...

---

## Service Communication

**Feign Client calls:**
- [service]: [method()] - [описание]

**Event Bus:**
- Publishes: [events]
- Subscribes: [events]

---

## Database

**Schema:** [service]_schema  
**Tables:**
- [table_name]: [описание]

---

## Implementation Notes

[Технические детали для БЭКТАСК агента]

---
```

---

## Frontend интеграция

При создании API задачи также указывать, как фронтенд будет использовать:

```markdown
## Frontend Usage

**Feature/Module:** [auth/characters/gameplay/etc]  
**API Client:** Generated by Orval  
**UI Components:** [components from UI Kit]

**Example:**
```typescript
import { useLogin } from '@/api/generated/auth';
import { CyberpunkButton } from '@/shared/ui';

function LoginForm() {
  const login = useLogin();
  
  return (
    <CyberpunkButton onClick={() => login.mutate(credentials)}>
      Login
    </CyberpunkButton>
  );
}
```
```

---

## Связанные документы

- [microservices-overview.md](05-technical/microservices-overview.md) - детали микросервисов
- [frontend-architecture-overview.md](05-technical/frontend-architecture-overview.md) - фронтенд архитектура
- [backend-architecture-overview.md](05-technical/backend-architecture-overview.md) - бэкенд архитектура
- [WORKFLOW-DETAILS-COMPACT.md](06-tasks/config/WORKFLOW-DETAILS-COMPACT.md) - воркфлоу проекта
- [API-SWAGGER/АПИТАСК.MD](../API-SWAGGER/АПИТАСК.MD) - инструкция для АПИТАСК в API-SWAGGER

---

## История изменений

- v1.0.0 (2025-11-07) - Создан документ с учетом микросервисной архитектуры

